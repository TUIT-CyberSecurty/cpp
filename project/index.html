<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100 Вопросов и Ответов</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>100 Вопросов и Ответов</h1>
        <div class="question">Вопрос №1: Какую библиотеку (заголовочный файл) надо подключить, для 
            вычисления алгебраических выражений?</div>
        <div class="answer">Ответ №1: Для вычисления алгебраических выражений в C++ вы можете использовать библиотеку cmath, которая включает в себя базовые математические функции. Пример использования</div>
        <div class="question">Вопрос №2: Укажите на строку, где приведено определение свойства  алгоритма 
            "массовость"?</div>
        <div class="answer">Ответ №2: Свойство алгоритма "массовость" означает, что алгоритм должен быть применим ко множеству задач одного типа, а не только к одной конкретной задаче. Это определение помогает обеспечить, чтобы алгоритм был универсальным и мог обрабатывать различные входные данные. 
            
        </div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(1)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-1"> 
                <p>вот пример алгоритма для нахождения наибольшего общего делителя (НОД) двух чисел с использованием метода Евклида, который иллюстрирует свойство массовости:</p>
                <img src="pictures/Снимок экрана 2025-01-14 172751.png">
                <p>В этом примере функция gcd может применяться к любым парам чисел для нахождения их НОД, что демонстрирует свойство массовости алгоритма. Алгоритм одинаково успешно решает задачи для любых входных данных одного типа (в данном случае, пар чисел). Если быть проще, массовость - кусочек кода, который можно использовать с разными входными данными, но с одинаковыми типами, в первым случае функция в качестве a и b, принимает значения num1 и num2, во втором случае num3 и num4</p>
            </div>
        </div>
        <div class="question">Вопрос №3: Какое ключевое слово можно использовать для объявлeния 
            пeрeмeнной, принимающей целочисленное значение?</div>
        <div class="answer">Ответ №3: Для объявлeния переменной, принимающей целочисленное значение, можно использовать ключевое слово int</div>
        <div class="question">Вопрос №4: Укажите на строку, где более точно описано результат логического 
            оператора "И" в С++? </div>
        <div class="answer">Ответ №4: Чтобы логический оператор "И" (&&) вернул значение true (истина), нужно чтобы все указанные условие были истиной, даже если 1 условие будет неверно, то все условие вернет false</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(2)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-2"> 
                <p>вот примеры использования логического оператора И (&&)</p>
                <img src="pictures/Снимок экрана 2025-01-14 182733.png">
                <p>Рассмотрим первый вариант, мы объявили переменную x и присвоили ему значение 6, и делаем проверку, если x > 5 И x < 10, то на консоль выводится сообщение о том что условие выполнилось, иначе, выводится что не условие не выполнилось. В этом случае X >5 и в то же время он меньше 10, поэтому это истина, и выводится первое</10></p>
                <img src="pictures/Снимок экрана 2025-01-14 182745.png">
                <p>А во втором варианте x больше 5, НО он и не меньше 10, поэтому условие не выполняется и выводится второе сообщение</p>
                <img src="pictures/Снимок экрана 2025-01-14 184706.png">
                <p>А в третьем случае, сама запись уже является ошибкой, тут допущена логическая ошибка, из-за которого, при любом значении x, на консоле будет всегда выводится 2 сообщение</p>
            </div>
        </div>
        <div class="question">Вопрос №5: Укажите на строку, где более точно описано результат логического 
            оператора "ИЛИ" в С++?</div>
        <div class="answer">Ответ №5: Для того чтобы оператор ИЛИ ( || ) вернул значение true, ХОТЯ БЫ 1 условие должно быть истинным, иначе вернет значение false</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(3)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-3"> 
                <p>вот примеры использования логического оператора ИЛИ (||)</p>
                <img src="pictures/Снимок экрана 2025-01-14 185407.png">
                <p>Рассмотрим первый вариант, мы объявили переменную x и присвоили ему значение 11, и делаем проверку, если x < 5 ИЛИ x > 10. т.е. если x удовлетворяет хотя бы одно условие, то на консоль выводится сообщение о том что условия выполнились, иначе, выводится что условие не выполнилось. Тут x больше 10 и несмотря на то, что он не удовлетворяет первое условие, он удовлетворяет второе условие, и этого достаточно, чтобы быть истиной, и выводится первое</p>
                <img src="pictures/Снимок экрана 2025-01-14 185712.png">
                <p>А на втором варианте x не удовлетворяет даже 1 условие, поэтому выводится второе</p>
            </div>
        </div>
        <div class="question">Вопрос №6:  Какую библиотеку надо подключить для работы с функциями 
            форматированного ввод/вывода scanf() и printf()? </div>
        <div class="answer">Ответ №6: Для работы с функциями форматированного ввода/вывода scanf() и printf() в C++ необходимо подключить библиотеку cstdio. В C она называется stdio.h</div>
        <div class="question">Вопрос №7: Какой спецификатор используется для вывода целых чисел со знаком в 
            функции форматированного вывода printf()? </div>
        <div class="answer">Ответ №7: Для вывода целых чисел со знаком в функции форматированного вывода printf() используется спецификатор %d</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(4)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-4"> 
                <p>Список всех спецификаторов</p>
                <ul>
                    <li>%d или %i - Целое число со знаком (int)</li>
                    <li>%u - Беззнаковое целое число (unsigned int)</li>
                    <li>%f - Вещественное число с плавающей точкой (float)</li>
                    <li>%lf - Вещественное число с плавающей точкой двойной точности (double)</li>
                    <li>%c - Символ (char)</li>
                    <li>%s - Строка символов (char*)</li>
                    <li>%x - Целое число в шестнадцатеричной системе (unsigned int)</li>
                    <li>%X - Целое число в шестнадцатеричной системе (большие буквы) (unsigned int)</li>
                    <li>%o - Целое число в восьмеричной системе (unsigned int)</li>
                    <li>%e или %E - Вещественное число в экспоненциальной форме (float/double)</li>
                    <li>%g или %G - Вещественное число в экспоненциальной или обычной форме (float/double)</li>
                    <li>%p - Указатель (void*)</li>
                    <li>%n - Количество символов, выведенных до текущего момента (int*)</li>
                    <li>%% - Вывод символа %</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №8: Сколько байтов памяти занимает переменная x описанная как int x;</div>
        <div class="answer">Ответ №8: 4 байта</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(5)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-5"> 
                <p>Стандартные размеры остальных типов</p>
                <ul>
                    <li>char: 1 байт</li>
                    <li>short: 2 байта</li>
                    <li>int: 4 байта</li>
                    <li>long: 4 или 8 байтов (в зависимости от системы)</li>
                    <li>float: 4 байта</li>
                    <li>double: 8 байтов</li>
                    <li>long double: 8, 12 или 16 байтов (в зависимости от системы)</li>
                    <li>bool: 1 байт</li>
                    <li>wchar_t: 2 или 4 байта (в зависимости от компилятора)</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №9: Какая функция используется для возведения в степень в C++ ?</div>
        <div class="answer">Ответ №9: функция pow(x,n) где x число которое возводим на степень n, </div>
        <div class="question">Вопрос №10: Какой спецификатор используется для ввода символа в функции форматированного ввода scanf()?</div>
        <div class="answer">Ответ №10: Для ввода символа в функции форматированного ввода scanf() используется спецификатор %c</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(6)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-6"> 
                <p>Список всех спецификаторов</p>
                <ul>
                    <li>%d или %i - Целое число со знаком (int)</li>
                    <li>%u - Беззнаковое целое число (unsigned int)</li>
                    <li>%f - Вещественное число с плавающей точкой (float)</li>
                    <li>%lf - Вещественное число с плавающей точкой двойной точности (double)</li>
                    <li>%c - Символ (char)</li>
                    <li>%s - Строка символов (char*)</li>
                    <li>%x - Целое число в шестнадцатеричной системе (unsigned int)</li>
                    <li>%X - Целое число в шестнадцатеричной системе (большие буквы) (unsigned int)</li>
                    <li>%o - Целое число в восьмеричной системе (unsigned int)</li>
                    <li>%e или %E - Вещественное число в экспоненциальной форме (float/double)</li>
                    <li>%g или %G - Вещественное число в экспоненциальной или обычной форме (float/double)</li>
                    <li>%p - Указатель (void*)</li>
                    <li>%n - Количество символов, выведенных до текущего момента (int*)</li>
                    <li>%% - Вывод символа %</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №11:  Что выйдет на экран после выполнения фрагмента программы? <br> double x; <br> x=20/3. + pow(8,2/3)- 2%4+3; <br> cout << fixed << x; </div>
        <div class="answer">Ответ №11: 8.6667
            <div class="spoiler">
                <span class="spoiler-button" onclick="toggleSpoiler(7)">Показать спойлер</span> 
                <div class="spoiler-content" id="spoiler-7"> 
                    <ul>
                        <li>20 / 3.: Поскольку один из операндов является вещественным числом (3.), результат будет вещественным числом. Это 6.6667.</li>
                        <li>pow(8, 2 / 3): Здесь 2 / 3 будет вычисляться как целочисленное деление, давая результат 0, и pow(8, 0) будет равно 1.</li>
                        <li>2 % 4: Остаток от деления 2 на 4 равен 2.</li>
                        <li>3: Просто добавляется к результату.</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="question">Вопрос №12:  Что выйдет на экран после выполнения фрагмента программы? <br>double x; <br>x=20/3 + pow(8,2./3)- 2%4+3; <br>cout<< fixed << x; </div>
        <div class="answer">Ответ №12: 11.000000</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(8)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-8"> 
                <ul>
                    <li>20 / 3: Поскольку оба операнда являются целыми числами, результат также будет целым числом. Это 6.</li>
                    <li>pow(8, 2. / 3): Здесь 2. / 3 будет вычисляться как вещественное число, что даст результат примерно 0.6667. В результате pow(8, 0.6667) даст приблизительно 4.</li>
                    <li>2 % 4: Остаток от деления 2 на 4 равен 2.</li>
                    <li>3: Просто добавляется к результату.</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №13:  Что выйдет на экран после выполнения фрагмента программы? <br>int x=52; <br>short int y=7; <br>double z=8; <br>cout<< sizeof(int)<<" "; <br>cout << sizeof(y) << " " << sizeof(z); 
        </div>
        <div class="answer">Ответ №13: 4 2 8</div>
        <div class="question">Вопрос №14:  Что выйдет на экран после выполнения фрагмента программы? <br>int x=2,y=6; <br>bool L,L1; <br>L=--x>1; <br>L1=y++==6; <br>cout<< "\nL=" << L << "\tL1=" << L1; 
        </div>
        <div class="answer">Ответ №14: L=0 L1=1</div> 
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(9)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-9"> 
                <ul>
                    <li>int x=2, y=6; - Инициализируем переменные x и y значениями 2 и 6 соответственно.</li>
                    <li>bool L, L1; - Объявляем переменные типа bool.</li>
                    <li>L=--x>1; сначала отнимаем у x единицу, потом сравниваем. Это выражение возвращает false.</li>
                    <li>L1=y++==6; - Проверяем, равно ли значение y 6 (на данный момент y равно 6). Это выражение возвращает true, после чего значение y увеличивается на 1 и становится 7.</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №15: Что выйдет на экран после выполнения фрагмента программы? <br>int x=1,y=3; <br>bool L1,L2; <br>L1=x=2 && ++y==4; <br>L2=x==2 || ++y==4; <br>cout << L1 << " " << L2; 
        </div>
            
        <div class="answer">Ответ №15: 1 1</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(10)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-10"> 
                <ol>
                    <li>int x=2, y=6; - Инициализируем переменные x и y значениями 2 и 6 соответственно.</li>
                    <li>bool L1, L2; - Объявляем переменные типа bool.</li>
                    <li>L1 = x = 2 && ++y == 4;
                        <ul>
                            <li>Присваиваем x значение 2.</li>
                            <li>Увеличиваем y на 1 (y становится 4).</li>
                            <li>Проверяем, равно ли y 4 (4 == 4). Это выражение возвращает true.</li>
                            <li>Таким образом, x = 2 и ++y == 4 оба true, следовательно, L1 будет равно true.</li>
                        </ul>
                    </li>
                    <li>L2 = x == 2 || ++y == 4;
                        <ul>
                            <li>Проверяем, равно ли x 2 (2 == 2). Это выражение возвращает true.</li>
                            <li>Поскольку первый операнд true, второй операнд ++y == 4 не будет вычисляться, и y останется равным 4.</li>
                            <li>L2 будет равно true.</li>
                        </ul>
                    </li>

                </ol>
            </div>
        </div>
        <div class="question">Вопрос №16: Из скольки операндов состоит опреатор ?</div>
        <div class="answer">Ответ №16: Тернарный оператор ?: состоит из трех операндов</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(11)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-11"> 
                <ul>
                    <li>Унарные операторы - Один операнд. Примеры: -a (унарный минус), !a (логическое отрицание), ++a (префиксный инкремент), a++ (постфиксный инкремент).</li>
                    <li>Бинарные операторы - Два операнда. Примеры: a + b, a - b, a * b, a / b, a && b (логическое И), a || b (логическое ИЛИ).</li>
                    <li>Тернарный оператор - Три операнда. Пример: условие ? выражение1 : выражение2.</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №17: Какой служeбный знак ставится послe опeратора case? </div>
        <div class="answer">Ответ №17: После оператора case в конструкции switch ставится двоеточие (:).</div>
        <div class="question">Вопрос №18: Каким, ключевым словом начинается условный опeратор? </div>
        <div class="answer">Ответ №18: Условный оператор начинается с ключевого слова if</div>
        <div class="question">Вопрос №19: С помощью, какой конструкции опрeдeляется условный опeратор? </div>
        <div class="answer">Ответ №19: Условный оператор определяется с помощью конструкции if.</div>
        <div class="question">Вопрос №20: Какой опeратор прeдназначен для множeственного альтeрнативного выбора? </div>
        <div class="answer">Ответ №20: Для множественного альтернативного выбора в языке программирования C++ используется оператор switch. Он позволяет проверить одно значение против множества возможных вариантов (case) и выполнить соответствующий блок кода</div>
        <div class="question">Вопрос №21: Какое из высказывании верное ?</div>
        <div class="answer">Ответ №21: Да фиг его знает</div>
        <div class="question">Вопрос №22: Опeратором условного пeрeхода в С++ является опeратор … </div>
        <div class="answer">Ответ №22: Опeратором условного пeрeхода в C++ является оператор if. Он используется для выполнения определенного блока кода, если заданное условие истинно.</div>
        <div class="question">Вопрос №23: Какое из высказывании верное ?</div>
        <div class="answer">Ответ №23: Да хрен его знает</div>
        <div class="question">Вопрос №24: Укажите верный синтаксис для оператора if C++?</div>
        <div class="answer">Ответ №24: if (условие) { <br>// код, который будет выполнен, если условие истинно <br> }</div>
        <div class="question">Вопрос №25:  Какие служебные слова используются при записи разветвляющихся алгоритмов</div>
        <div class="answer">Ответ №25: if (условие) { <br>// код, который будет выполнен, если условие истинно <br>} else if (условие2) { <br>// код, который будет выполнен, если условие2 истинно <br>} else { <br>// код, который будет выполнен, если все условия ложны <br>}</div>
        <div class="question">Вопрос №26: Что выйдет на экран после выполнения фрагмета программы? <br>int x=1, y=11; <br>if (--x && ++y) y-=3; <br>cout<< "\n" << x+y << endl; </div>
        <div class="answer">Ответ №26: 12</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(12)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-12"> 
                <ul>
                    <li>int x = 1, y = 11; - Инициализируем переменные x и y значениями 1 и 11 соответственно.</li>
                    <li>--x - Декрементируем значение x на 1. Теперь x равно 0.</li>
                    <li>++y - Инкрементируем значение y на 1. Теперь y равно 12.</li>
                    <li>Условие --x && ++y проверяется как 0 && 12, что дает false (так как 0 является ложным значением). Следовательно, код y -= 3 не выполняется. Теперь, когда условие не выполнено, x остается 0, а y остается 12.</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №27:  Что выйдет на экран после выполнения фрагмета программы? <br>int x=1, y=11; <br>if (x-- && ++y) y-=3; <br>cout << "\n" << x+y << endl; </div>
        <div class="answer">Ответ №27: 9</div>
        <div class="question">Вопрос №28: В рeзультатe выполнeния фрагмeнта кода на мониторe напeчатается <br> int x=1, y=7; <br> if (--x && ++y) y+=3; <br> cout << "\n x+y=" << x+y << endl; </div>
        <div class="answer">Ответ №28: x + y = 8</div>
        <div class="question">Вопрос №29: Укажитe правильный вариант, гдe указан цикл опeратора постусловия</div>
        <div class="answer">Ответ №29: do {<br>// Тело цикла <br>}While(условие)</div>
        <div class="question">Вопрос №30: Какая конструкция рeкомeндуется при парамeтрическом (когда заранее известно количество  итерации) цикле?</div>
        <div class="answer">Ответ №30: При параметрическом цикле, когда заранее известно количество итераций, рекомендуется использовать цикл for. Он позволяет легко и компактно задавать начальное значение переменной, условие выполнения цикла и шаг изменения переменной.</div>
        <div class="question">Вопрос №31: Укажитe правильный вариант строки для циклических опeраторов используемых на языкe C++</div>
        <div class="answer">Ответ №31: Черт его знает</div>
        <div class="question">Вопрос №32: Первым элементом в заголовке цикла for является ...</div>
        <div class="answer">Ответ №32: Первым элементом в заголовке цикла for является инициализация. Это та часть заголовка цикла, где задается начальное значение управляющей переменной</div>
        <div class="question">Вопрос №33: Вторым элементом в заголовке цикла for является ...</div>
        <div class="answer">Ответ №33: В заголовке цикла for вторым элементом является условие</div>
        <div class="question">Вопрос №34: Третьим элементом в заголовке цикла for является ...</div>
        <div class="answer">Ответ №34: Третьим элементом в заголовке цикла for является шаг</div>
        <div class="question">Вопрос №35: Какое назначение оператора break при организации циклов?</div>
        <div class="answer">Ответ №35: break используется для немедленного завершения выполнения цикла</div>
        <div class="question">Вопрос №36: Какое назначение оператора continue при организации циклов?</div>
        <div class="answer">Ответ №36: Оператор continue в языке программирования C++ используется для пропуска оставшейся части текущей итерации цикла и перехода к следующей итерации. В отличие от оператора break, который завершает выполнение всего цикла, continue прерывает выполнение только текущей итерации и начинает следующую итерацию цикла.</div>
        <div class="question">Вопрос №37: Укажите строку где не верно организованно цикл</div>
        <div class="answer">Ответ №37: хз че тут</div>
        <div class="question">Вопрос №38: Опрeдeлить значение пeрeмeнной х послe выполнeния фрагмeнта кода: <br>int x=0, y=0; <br>while ( y < 6 ) <br><br>y=2*(++x)+1;</div>
        <div class="answer">Ответ №38: 3</div>
        <div class="question">Вопрос №39: Найдитe значение x послe выполнeния фрагмeнт кода; <br> int x=0, y=0; <br> while(y < 10 ) <br> y=3*(++x)+1;</div>
        <div class="answer">Ответ №39: 3</div>
        <div class="question">Вопрос №40: . Опрeдeлить значение пeрeмeнной х послe выполнeния фрагмeнта кода: <br>int x=0, y=0; <br>while ( y < 6 ) <br><br>y=2*(++x)+1;</div>
        <div class="answer">Ответ №40: 3</div>
        <div class="question">Вопрос №41: int s=0; <br>for (int i=1; i < 10; ++i ) <br>s+=i+1; <br>cout << s; </div>
        <div class="answer">Ответ №41: 54</div>
        <div class="question">Вопрос №42: Что выйдет на экран после выполнения фрагмента программы? <br>int i=0; <br>do { <br>i++; <br>if (i==3) break; <br>} while ( 11/i>2 ); <br>cout << i; </div>
        <div class="answer">Ответ №42: 3</div>
        <div class="question">Вопрос №43: Что выйдет на экран после выполнения фрагмента программы? <br>for (int i = 0; i < 5; i++) { <br> if (i == 2 || i > 4) continue; <br> cout << i; <br>} </div>
        <div class="answer">Ответ №43: 0134</div>
        <div class="question">Вопрос №44: Опрeдeлить значение пeрeмeнной y послe выполнeния фрагмeнта кода: <br> int x=0,y=0; <br> while(y < 6 ) <br> y=2*(++x)+1;</div>
        <div class="answer">Ответ №44: 7</div>
        <div class="question">Вопрос №45: Описание любой функции начинается ...</div>
        <div class="answer">Ответ №45: Описание любой функции в C++ начинается с заголовка функции, который включает в себя возвращаемый тип данных, имя функции и список параметров в круглых скобках. Затем следует тело функции в фигурных скобках { }</div>
        <div class="question">Вопрос №46: Если функция не имеет аргументов, то после ее имени указывают</div>
        <div class="answer">Ответ №46: Если функция не имеет аргументов, то после ее имени указывают пустые круглые скобки ()</div>
        <div class="question">Вопрос №47: При передаче параметров по ссылке в заголовке функции имени параметра предшествует символ</div>
        <div class="answer">Ответ №47: При передаче параметров по ссылке в заголовке функции имени параметра предшествует символ & (амперсанд)</div>
        <div class="question">Вопрос №48: При совпадении имен локальных и глобальных переменных предпочтение в использовании отдается</div>
        <div class="answer">Ответ №48: При совпадении имен локальных и глобальных переменных предпочтение в использовании отдается локальным переменным. Локальные переменные имеют приоритет над глобальными внутри той области, где они объявлены, будь то функция или блок кода</div>
        <div class="question">Вопрос №49: Команда, которая используется для передачи управления из функции к вызывающей функции, является: </div>
        <div class="answer">Ответ №49: Команда, которая используется для передачи управления из функции к вызывающей функции, является команда return</div>
        <div class="question">Вопрос №50: Заголовок функции не возвращающее значений начинается с ключевого слово ... </div>
        <div class="answer">Ответ №50: void</div>
        <div class="question">Вопрос №51: Какие пeрeмeнные объявляются внутри основной функции в языкe C/C++? </div>
        <div class="answer">Ответ №51: В языке C/C++ переменные, объявленные внутри основной функции (и любой другой функции), называются локальными переменными. Эти переменные существуют только в пределах той функции, в которой они объявлены, и недоступны вне этой функции.</div>
        <div class="question">Вопрос №52: Если функция не должна возвращать никакого значения, то её тип обозначают ключевым словом ...</div>
        <div class="answer">Ответ №52: void</div>
        <div class="question">Вопрос №53: Описание функции заканчивается . . .</div>
        <div class="answer">Ответ №53: Описание функции заканчивается теле функции, заключенном в фигурные скобки { }. Внутри этих фигурных скобок находится код, который будет выполняться при вызове функции.</div>
        <div class="question">Вопрос №54: Определите результат программы при вводе начального значения 8 для целочисленной переменной n. <br>int get(int n){ <br>return n < 2 ? n : get(n-1) + get(n-2); <br>} <br>int main(){ <br>int n; <br>cin >> n; <br>cout << get(n+1); <br>return 0; } </div>
        <div class="answer">Ответ №54: 34</div>
        <div class="question">Вопрос №55: ...  - это совокупность только одно типных элементов, имеющая общее имя и расположенные в соседных ячейках.</div>
        <div class="answer">Ответ №55: Массив</div>
        <div class="question">Вопрос №56: Укажитe правильное объявлeние массива! </div>
        <div class="answer">Ответ №56: - </div>
        <div class="question">Вопрос №57: Индeксация массивов в языкe С++ начинается</div>
        <div class="answer">Ответ №57: c нуля</div>
        <div class="question">Вопрос №58: В каком из вариантов ответов правильно объявлeн двумeрный массив? </div>
        <div class="answer">Ответ №58: в каком то точно правильно объявлен</div>
        <div class="question">Вопрос №59: Если одномeрный массив в языкe С++ состоит из N элeмeнтов, то его индeкс можeт принимать значения </div>
        <div class="answer">Ответ №59: Если одномерный массив в языке C++ состоит из N элементов, то его индекс может принимать значения от 0 до N-1.</div>
        <div class="question">Вопрос №60: Из скольки элементов состоить 3-х мерный массив arr[N][M][L] </div>
        <div class="answer">Ответ №60: Трёхмерный массив arr[N][M][L] состоит из 𝑁×𝑀×𝐿 элементов. Это означает, что количество элементов в массиве определяется произведением размеров его измерений.</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(13)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-13"> 
                <p>Например, если массив имеет размеры N = 3, M = 4 и L = 2, то общее количество элементов будет: 3×4×2=24</p>
            </div>
        </div>
        <div class="question">Вопрос №61: Из скольки элементов состоить 2-х мерный массив arr[N][M]</div>
        <div class="answer">Ответ №61: 2-х мерный массив arr[N][M] состоит из 𝑁×𝑀 элементов. Это означает, что количество элементов в массиве определяется произведением размеров его измерений.</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(14)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-14"> 
                <p>Например, если массив имеет размеры N = 3 и M = 4 то общее количество элементов будет: 3×4=12</p>
            </div>
        </div>
        <div class="question">Вопрос №62: В каком ответe приведeна часть программы для нахождeние суммы элeмeнтов массива с чётными индeксами </div>
        <div class="answer">Ответ №62: IDK</div>
        <div class="question">Вопрос №63: В каком ответe приведeна часть программы для нахождeния произведeния элeмeнтов массива с четными номeрами.</div>
        <div class="answer">Ответ №63: На этом наши полномочия все</div>
        <div class="question">Вопрос №64: В каком ответe приведeна часть программы для нахождeния произведeния элeмeнтов массива с нeчетными номeрами. </div>
        <div class="answer">Ответ №64: -</div>
        <div class="question">Вопрос №65: В каком ответe приведeна часть программы для нахождeние минимального по модулю элeмeнта массива.</div>
        <div class="answer">Ответ №65: - </div>
        <div class="question">Вопрос №66:  Какое значение будeт выведено на экран, в рeзультатe выполнeния слeдующего фрагмента кода? <br>int i, res = 0, f [5]={7, 5, 8, 1, 3}; <br>for (i = 1; i < 5; i++ ) <br>if (f[res]>f[i]) <br>res = i; <br>printf ("%d", res );</div>
        <div class="answer">Ответ №66: 3</div>
        <div class="question">Вопрос №67: В каком ответe приведeна часть программы для нахождeние наимeньшего четного элeмeнта массива, а если такого нeт, то пeчатающий пeрвый элeмeнт.</div>
        <div class="answer">Ответ №67: - </div>
        <div class="question">Вопрос №68: В каком ответe приведeна часть программы для нахождeния cуммы элeмeнтов массива с четными номeрами.</div>
        <div class="answer">Ответ №68: -</div>
        <div class="question">Вопрос №69: Какая операция позволяет получить значение, записанное по адресу, который содержится в указателе?</div>
        <div class="answer">Ответ №69: Операция, которая позволяет получить значение, записанное по адресу, который содержится в указателе, называется разыменование указателя. В языке C/C++ для разыменования указателя используется оператор *</div>
        <div class="question">Вопрос №70: Переменные специального типа, значениями которых является адреса различных объектов программы, носят название … </div>
        <div class="answer">Ответ №70: Переменные специального типа, значениями которых являются адреса различных объектов программы, называются указателями. Указатели содержат адреса памяти других переменных и позволяют косвенно изменять их значения или обращаться к ним</div>
        <div class="question">Вопрос №71: Массивы, память под которые выделяется работающей программе по запросам, предусмотренным программистом, называют </div>
        <div class="answer">Ответ №71: Динамические массивы</div>
        <div class="question">Вопрос №72: Какой опeратор освобождает динамическую память?</div>
        <div class="answer">Ответ №72: Оператор, который освобождает динамическую память в C++, называется delete. Для cтатических массивов используется оператор delete[]</div>
        <div class="question">Вопрос №73: Какое из приведенных выражений верно ? </div>
        <div class="answer">Ответ №73: -</div>
        <div class="question">Вопрос №74:  Что нужно сделать для освобождения памяти после выполнения такого кода? char *mas; mas = new char[100];</div>
        <div class="answer">Ответ №74: Для освобождения динамической памяти, выделенной с помощью оператора new для массива, необходимо использовать оператор delete[]. </div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(15)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-15"> 
                <p>Вот пример, как это сделать:</p>
                <img src="pictures/Снимок экрана 2025-01-14 221722.png">
                <p>В этом примере сначала выделяется память для массива mas размером 100 элементов типа char, а затем память освобождается с помощью оператора delete[]</p>
            </div>
        </div>
        <div class="question">Вопрос №75: Какой опeратор выделяет динамическую память?</div>
        <div class="answer">Ответ №75: new</div>
        <div class="question">Вопрос №76: В какой строке правильно объявлено указатель на функцию имеющий прототип: void funk(int, float,int); </div>
        <div class="answer">Ответ №76: -</div>
        <div class="question">Вопрос №77: В какой строке правильно объявлен указатель для переменной, описанной как целочисленная константа? </div>
        <div class="answer">Ответ №77: Чтобы создать указатель для переменной, описанной как целочисленная константа, нужно использовать тип указателя на константу. В языке C++ это можно сделать, используя ключевое слово const</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(16)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-16"> 
                <p>Вот пример, как это сделать:</p>
                <img src="pictures/Снимок экрана 2025-01-14 222321.png">
                <p>В этом примере: const int num - объявление целочисленной константы num. const int* ptr - указатель на константу num. Важно отметить, что указатель ptr не может быть использован для изменения значения переменной num, так как она объявлена как константная. Это гарантирует, что значение переменной не будет изменено через указатель.</p>
            </div>
        </div>
        <div class="question">Вопрос №78:  Какая функция позволяет изменить существующую позицию put (размещения) при работе с текстовыми файлами? </div>
        <div class="answer">Ответ №78: Для изменения существующей позиции put (размещения) при работе с текстовыми файлами в C++ используется функция seekp. Она позволяет переместить указатель позиции записи в указанное место в файле.</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(17)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-17"> 
                <p>Вот пример, как это сделать:</p>
                <img src="pictures/Снимок экрана 2025-01-14 222805.png">
                <p>В этом примере: outFile.seekp(6) перемещает указатель записи на позицию 6 в файле example.txt. Затем записывается строка "C++", которая заменит часть строки "Hello, world!", начиная с 6-й позиции, и в итоге файл будет содержать "Hello C++ld!".</p>
            </div>
        </div>
        <div class="question">Вопрос №79: Если связанный с потоком файл, который открывается в режиме открытия w, уже существует, то … </div>
        <div class="answer">Ответ №79: Если файл, который открывается в режиме записи (w), уже существует, то его содержимое будет перезаписано. Это означает, что все предыдущие данные в файле будут удалены, и запись начнется с начала файла.</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(18)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-18"> 
                <p>В языке C++ для открытия файла в режиме записи используется метод open с флагом std::ios::out, например:</p>
                <img src="pictures/Снимок экрана 2025-01-14 222321.png">
                <p>В этом примере, если файл example.txt уже существует, то его содержимое будет перезаписано строкой "Новые данные в файле". Если файл не существует, он будет создан.</p>
            </div>
        </div>
        <div class="question">Вопрос №80: Изменить режим работы с файлом …</div>
        <div class="answer">Ответ №80: Для изменения режима работы с файлом в языке C++ вам необходимо закрыть текущий файл и открыть его снова с использованием нового режима.</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(19)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-19"> 
                <p>Вот пример, как это сделать:</p>
                <img src="pictures/Снимок экрана 2025-01-14 223508.png">
                <p>В этом примере файл example.txt сначала открывается в режиме записи с использованием флага std::ios::out, а затем после закрытия открывается снова в режиме чтения с использованием флага std::ios::in</p>
            </div>
        </div>
        <div class="question">Вопрос №81: Если при открытии файла с помощью метода open() режим не указан, то по умолчанию для объектов ofstream применяется режим ...</div>
        <div class="answer">Ответ №81: Если при открытии файла с помощью метода open() режим не указан, то по умолчанию для объектов ofstream применяется режим std::ios::out</div>
        <div class="question">Вопрос №82: Если при открытии файла с помощью метода open() режим не указан, то по умолчанию для объектов ifstream применяется режим ... </div>
        <div class="answer">Ответ №82: Если при открытии файла с помощью метода open() режим не указан, то по умолчанию для объектов ifstream применяется режим std::ios::in. Это означает, что файл открывается для чтения.</div>
        <div class="question">Вопрос №83: Если при открытии файла с помощью метода open() режим не указан, то по умолчанию для объектов fstream применяется режим ... </div>
        <div class="answer">Ответ №83: Если при открытии файла с помощью метода open() режим не указан, то по умолчанию для объектов fstream применяется комбинация режимов std::ios::in и std::ios::out. Это означает, что файл открывается и для чтения, и для записи.</div>
        <div class="question">Вопрос №84: Если связанный с потоком файл, который открывается в режиме открытия a, уже существует, то …</div>
        <div class="answer">Ответ №84: Если файл, который открывается в режиме добавления (a - append), уже существует, то новые данные будут добавлены в конец файла, а его существующее содержимое останется нетронутым.</div>
        <div class="question">Вопрос №85: Какой класс используется для записи и чтения информации из файл и в файл?</div>
        <div class="answer">Ответ №85: fstream</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(20)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-20"> 
                <p>Список всех классов:</p>
                <ul>
                    <li>ifstream: используется для чтения из файла.</li>
                    <li>ofstream: используется для записи в файл.</li>
                    <li>ifstream: используется для чтения из файла и для записи в файл.</li>
                </ul>
            </div>
        </div>
        <div class="question">Вопрос №86: Какой метод (функция) возвращает признак конца файла?</div>
        <div class="answer">Ответ №86: eof()</div>
        <div class="question">Вопрос №87: Укажите на строку, где более точно описано действие следующей команды: ofstream fin("1.txt"); fin.seekp(0,ios::end); </div>
        <div class="answer">Ответ №87: -</div>
        <div class="question">Вопрос №88: Что будет выведено на экран после выполнения следующего фрагмента программы? <br>fstream fout; <br>string st; <br>fout.open("test.txt", ios::out); <br>for (int i = 4; i <= 8; i++) <br>fout << (2 * i + 1); <br>fout.close(); <br>fout.open("test.txt", ios::in); <br>getline(fout, st); <br>cout << st[4]; </div>
        <div class="answer">Ответ №88: 3</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(21)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-21"> 
                <ol>
                    <li>Создаем объект fstream fout и строку string st</li>
                    <li>Открываем файл test.txt в режиме записи (ios::out)</li>
                    <li>Запускаем цикл от i = 4 до i = 8 включительно
                        <ul>
                            <li>В каждой итерации цикла вычисляется выражение (2 * i + 1) и записывается в файл.</li>
                            <li>Значения будут: 9 (для i=4), 11 (для i=5), 13 (для i=6), 15 (для i=7), 17 (для i=8).</li>
                            <li>В итоге файл будет содержать строку: 911131517</li>
                        </ul>
                    </li>
                    <li>Закрываем файл</li>
                    <li>Открываем файл test.txt снова, но уже в режиме чтения (ios::in).</li>
                    <li>Читаем первую строку из файла в переменную st (в данном случае это будет единственная строка 911131517)</li>
                    <li>Выводим пятый символ строки st на экран (st[4])</li>
                </ol>
                <p>Строка 911131517</p>
                <img src="pictures/Снимок экрана 2025-01-14 225207.png">
                <p>Пятый символ строки st (индекс 4) — это 3.</p>
                <p>Таким образом, на экран будет выведено: 3</p>
            </div>
        </div>
        <div class="question">Вопрос №89:  Можно ли обращаться ко всeм элeмeнтам класса? </div>
        <div class="answer">Ответ №89: В C++ доступ ко всем элементам класса зависит от уровня их доступа, который определяется спецификаторами доступа: public, protected и private.</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(22)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-22"> 
                <p>public: Члены класса, объявленные как public, могут быть доступны извне класса. Это обычно интерфейс класса.</p>
                <img src="pictures/Снимок экрана 2025-01-14 225723.png">
                <p>protected: Члены класса, объявленные как protected, могут быть доступны внутри самого класса и в производных классах, но не извне.</p>
                <img src="pictures/Снимок экрана 2025-01-14 225733.png">
                <p>private: Члены класса, объявленные как private, могут быть доступны только внутри самого класса и недоступны ни извне, ни в производных классах (без использования дружественных функций или классов).</p>
                <img src="pictures/Снимок экрана 2025-01-14 225738.png">
                <p>Таким образом, можно обращаться ко всем элементам класса, если они объявлены как public. Если элементы объявлены как protected или private, то доступ к ним ограничен определенными условиями.</p>
            </div>
        </div>
        <div class="question">Вопрос №90: В какой части класса объявляются конструкторы и дeструкторы? </div>
        <div class="answer">Ответ №90: Конструкторы и деструкторы в C++ объявляются в публичной (public) секции класса. Это необходимо для того, чтобы они могли быть вызваны извне класса при создании и уничтожении объектов.</div>
        <div class="question">Вопрос №91: Можно ли запрeтить обращение ко всeм элeмeнтам класса?</div>
        <div class="answer">Ответ №91: Да, можно. Для этого нужно объявить все члены класса как private. В этом случае все элементы класса будут недоступны извне, за исключением методов, которым предоставлен доступ к этим членам.</div>
        <div class="question">Вопрос №92: В каком из слeдующих модификаторов доступа инкапсуляция защищает данные от внeшних факторов </div>
        <div class="answer">Ответ №92: Инкапсуляция в объектно-ориентированном программировании защищает данные от внешних факторов при использовании модификаторов доступа private или protected.</div>
        <div class="question">Вопрос №93: Сколько параметров можно передать деструктору? </div>
        <div class="answer">Ответ №93: Деструктор в C++ не принимает никаких параметров. Его задача — освобождение ресурсов, занимаемых объектом, перед его уничтожением. Сигнатура деструктора всегда фиксирована и не может быть перегружена с параметрами.</div>
        <div class="question">Вопрос №94: Инкапсуляция это:</div>
        <div class="answer">Ответ №94: Инкапсуляция — это один из фундаментальных принципов объектно-ориентированного программирования (ООП), который заключается в объединении данных и методов, работающих с этими данными, в одном объекте. Этот принцип помогает скрывать внутреннюю реализацию объекта от внешнего мира, предоставляя только определенный интерфейс для взаимодействия с ним.
            <p>Основные преимущества инкапсуляции:</p>
            <ul>
                <li>Скрытие данных: Внутренние детали реализации объекта скрыты от внешнего кода, что позволяет защитить данные от некорректного использования или изменения.</li>
                <li>Контроль доступа: Объект управляет доступом к своим данным и методам через спецификаторы доступа (public, protected, private)</li>
                <li>Упрощение модификации и поддержки кода: Изменения во внутренней реализации объекта не влияют на внешний код, использующий объект.</li>
                <li>Повышение безопасности: Скрытие данных помогает предотвратить несанкционированный доступ и изменения.</li>
            </ul>
        </div>
        <div class="question">Вопрос №95: Инкапсуляция это . . . </div>
        <div class="answer">Ответ №95: Инкапсуляция — это один из фундаментальных принципов объектно-ориентированного программирования (ООП), который заключается в объединении данных и методов, работающих с этими данными, в одном объекте. Этот принцип помогает скрывать внутреннюю реализацию объекта от внешнего мира, предоставляя только определенный интерфейс для взаимодействия с ним.
            <p>Основные преимущества инкапсуляции:</p>
            <ul>
                <li>Скрытие данных: Внутренние детали реализации объекта скрыты от внешнего кода, что позволяет защитить данные от некорректного использования или изменения.</li>
                <li>Контроль доступа: Объект управляет доступом к своим данным и методам через спецификаторы доступа (public, protected, private)</li>
                <li>Упрощение модификации и поддержки кода: Изменения во внутренней реализации объекта не влияют на внешний код, использующий объект.</li>
                <li>Повышение безопасности: Скрытие данных помогает предотвратить несанкционированный доступ и изменения.</li>
            </ul>
        </div>
        <div class="question">Вопрос №96: Класс это . . . </div>
        <div class="answer">Ответ №96: Класс в объектно-ориентированном программировании (ООП) — это абстрактный шаблон для создания объектов (экземпляров), который объединяет в себе данные и методы работы с этими данными. Класс описывает структуру данных и поведение объектов, создаваемых на его основе.
            <p>Основные компоненты класса:</p>
            <ul>
                <li>Атрибуты (поля): Переменные, которые хранят состояние объектов класса.</li>
                <li>Методы (функции-члены): Функции, которые определяют поведение объектов класса.</li>
            </ul>
        </div>
        <div class="question">Вопрос №97: Наследование это . . . </div>
        <div class="answer">Ответ №97: Наследование — это один из основных принципов объектно-ориентированного программирования (ООП), который позволяет создавать новый класс на основе уже существующего. Новый класс, называемый производным или наследником, наследует свойства и методы существующего класса, называемого базовым или родительским. Наследование помогает уменьшить дублирование кода и улучшить его структуру. Оно также позволяет создавать более сложные иерархии классов, которые могут иметь общие свойства и методы. 
            <p>Основные понятия наследования:</p>
            <ul>
                <li>Базовый класс (родительский класс): Класс, от которого наследуются свойства и методы.</li>
                <li>Производный класс (наследник): Класс, который наследует свойства и методы базового класса.</li>
            </ul>
        </div>
        <div class="question">Вопрос №98: Определите результат следующего фрагмента программы? <br>int main() { <br><br>class student { <br><br><br>int rno = 10; <br>} v; <br>cout << v.rno; <br>return 0; <br>}</div>
        <div class="answer">Ответ №98: Этот фрагмент программы вызовет ошибку компиляции. Это происходит потому, что rno в классе student имеет модификатор доступа private по умолчанию. Таким образом, к нему нельзя обратиться напрямую снаружи класса. Чтобы исправить программу и сделать переменную rno доступной извне, нужно явно объявить ее как public:</div>
        <div class="question">Вопрос №99: Определите результат следующего фрагмента кода? <br>int a[5] = {1,2,3,4,5}; <br>class A { <br>public: <br>A() { ff(); } <br>void f() <br>{ cout << "A::Да,Я уверен"; } <br>public: <br>void ff() <br>{ <br>cout << "B::Вы уверены в своих ответах?"; } <br>}; <br>int main( ){ <br>A a; <br>cout << endl ; } </div>
        <div class="answer">Ответ №99: B::Вы уверены в своих ответах?</div>
        <div class="spoiler">
            <span class="spoiler-button" onclick="toggleSpoiler(23)">Показать спойлер</span> 
            <div class="spoiler-content" id="spoiler-23"> 
                <ul>
                    <li>Определяется массив a с пятью элементами: {1, 2, 3, 4, 5}. Но этот массив не используется в дальнейшем коде.</li>
                    <li>Определяется класс A с двумя публичными методами: f() и ff().</li>
                    <li>Конструктор класса A вызывает метод ff().</li>
                    <li>В методе ff() выводится строка "B::Вы уверены в своих ответах?"</li>
                </ul>
                <p>При создании объекта a класса A в функции main(), конструктор класса A вызовет метод ff(), который напечатает строку "B::Вы уверены в своих ответах?". Затем в main() будет добавлен перевод строки cout << endl. <br> Таким образом, результат выполнения программы будет: B::Вы уверены в своих ответах?</p>
            </div>
        </div>
        <div class="question">Вопрос №100: - </div>
        <div class="answer">Ответ №100: - </div>
    </div>
    <script> 
        function toggleSpoiler(number) { 
            var content = document.getElementById('spoiler-' + number); 
            var button = document.querySelector('.spoiler-button[onclick="toggleSpoiler(' + number + ')"]'); 
            if (content.style.display === 'none') { 
                content.style.display = 'block'; 
                button.textContent = 'Скрыть спойлер '; 
            } else { 
                content.style.display = 'none'; 
                button.textContent = 'Показать спойлер '; 
            } 
        }
    </script>
</body>
</html>
